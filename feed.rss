<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>ojikeii's blog</title>
		<link>http://ojikeii.net/</link>
		<description>ojikeii's blog</description>
		<copyright>2019</copyright>
		<pubDate>Sun, 24 Mar 2019 16:09:35 GMT</pubDate>
		<lastBuildDate>Sun, 24 Mar 2019 16:09:35 GMT</lastBuildDate>
		<item>
			<link>http://ojikeii.net/posts/2019-03-24-235451</link>
			<guid>http://ojikeii.net/posts/2019-03-24-235451</guid>
			<pubDate>Sun, 24 Mar 2019 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>Azure Logic Apps テスト用の投稿</title>
			<link>http://ojikeii.net/posts/2018-03-21-184821</link>
			<description>&lt;p&gt;Azure Logic Apps のチュートリアルの動作確認のためのテストです。&lt;/p&gt;</description>
			<guid>http://ojikeii.net/posts/2018-03-21-184821</guid>
			<pubDate>Wed, 21 Mar 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Azure Logic Apps のチュートリアルの動作確認のためのテストです。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>IoT システム開発スタートアップを読んで手を動かしてみたときのメモ</title>
			<link>http://ojikeii.net/posts/2018-01-11-001229</link>
			<description>&lt;p&gt;先月「&lt;a href="https://www.amazon.co.jp/IoT%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%A2%E3%83%83%E3%83%97-%E3%83%97%E3%83%AD%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97%E3%81%A7%E5%85%A8%E3%83%AC%E3%82%A4%E3%83%A4%E3%82%92%E3%81%A4%E3%81%AA%E3%81%90-%E5%90%89%E6%BE%A4-%E7%A9%82%E7%A9%8D/dp/4865940944"&gt;IoT システム開発スタートアップ-プロトタイプで全レイヤをつなぐ&lt;/a&gt;」を読んだときのメモ。&lt;/p&gt;</description>
			<guid>http://ojikeii.net/posts/2018-01-11-001229</guid>
			<pubDate>Thu, 11 Jan 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;先月「&lt;a href="https://www.amazon.co.jp/IoT%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%A2%E3%83%83%E3%83%97-%E3%83%97%E3%83%AD%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97%E3%81%A7%E5%85%A8%E3%83%AC%E3%82%A4%E3%83%A4%E3%82%92%E3%81%A4%E3%81%AA%E3%81%90-%E5%90%89%E6%BE%A4-%E7%A9%82%E7%A9%8D/dp/4865940944"&gt;IoT システム開発スタートアップ-プロトタイプで全レイヤをつなぐ&lt;/a&gt;」を読んだときのメモ。&lt;/p&gt;
&lt;h1 id="bleserial3"&gt;BLESerial3 を使う&lt;/h1&gt;
&lt;p&gt;本では BLESerial2 を使っていたが&lt;a href="https://qiita.com/tomonari-t/items/d821fc5b4f05189828fa#bleserial2%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83"&gt;すでに生産が停止されているよう&lt;/a&gt;で手に入らなかったので BLESerial3 を使った。BLESerial2 と BLESerial3 ではマイコンとの接続方法が微妙に異なる。前者は マイコンの TX は モジュールの TX、RX は RX に接続するが、後者の場合は TX は RX、RX は TX に接続する。  なので BLESerial3 を使う場合は本の通りに接続しても期待通りに動かない。「&lt;a href="http://www.robotsfx.com/robot/BLESerial3.html"&gt;BLEモジュール　BLESerial３　の紹介&lt;/a&gt;」の「3.3V系マイコンとの接続例」を参考にした。&lt;/p&gt;
&lt;h1 id="ble-central"&gt;ゲートウェイ（BLE Central）のプログラム&lt;/h1&gt;
&lt;p&gt;BLESerail3 が送信したデータを Raspberry Pi 上の Windows 10 IoT で受信するためのコードを書く必要があるが、本にあるコードでは上手くいかなかった。代わりに下記のコードでとりあえず動いた。&lt;a href="https://docs.microsoft.com/en-us/windows/uwp/devices-sensors/gatt-client"&gt;UWP の Bluetooth GATT Client 用 API のドキュメント&lt;/a&gt; を参考にした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private async void HookGattCharacteristicAsync()
{
    // 結局デバイスの名前指定して取ることにした。
    deviceInfos = await DeviceInformation.FindAllAsync(
        BluetoothLEDevice.GetDeviceSelectorFromDeviceName(&amp;quot;BLESerial_0&amp;quot;)
        );

    if (deviceInfos == null || deviceInfos.Count != 1) return;

    BluetoothLEDevice bleDevice = await BluetoothLEDevice.FromIdAsync(deviceInfos.First().Id);

    GattDeviceServicesResult gattDeviceServices = await bleDevice.GetGattServicesForUuidAsync(GattServiceGuid);

    if (gattDeviceServices.Status == GattCommunicationStatus.Success)
    {
        gattCharacteristics = await gattDeviceServices.Services.First().GetCharacteristicsForUuidAsync(GattCharacteristicGuid);

        if (this.gattCharacteristics.Status == GattCommunicationStatus.Success)
        {
            var gattCharacteristic = this.gattCharacteristics.Characteristics.First();

            // CCCD への書き込みが必要。これがないとイベントハンドラが呼ばれない。
            GattCommunicationStatus status
                = await gattCharacteristic.WriteClientCharacteristicConfigurationDescriptorAsync(GattClientCharacteristicConfigurationDescriptorValue.Notify);

            if (status == GattCommunicationStatus.Success)
            {
                gattCharacteristic.ValueChanged += GattCharacteristic_ValueChanged;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="bing-image-search-api-v7"&gt;Bing Image Search API v7 を使う&lt;/h1&gt;
&lt;p&gt;害鳥検出システムの教師データ用の画像収集プログラムで Bing Image Search API v5 を使っているが、v7 があったのでそちらを使ってみた。本では検索結果の重複を避けるため、現在のオフセットに、1回のクエリで取得する最大件数と &lt;a href="https://docs.microsoft.com/ja-jp/rest/api/cognitiveservices/bing-images-api-v5-reference#nextoffsetaddcount"&gt;nextOffsetAddCount&lt;/a&gt; を加えたものを次回クエリのオフセットに指定している。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;offset += BING_SKIP + result['nextOffsetAddCount'] # v5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;v7 では nextOffsetAddCount は存在しない。代わりに &lt;a href="https://docs.microsoft.com/ja-jp/rest/api/cognitiveservices/bing-images-api-v7-reference#nextoffset"&gt;nextOffset&lt;/a&gt; の値をそのまま次回クエリのオフセットに指定する。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;offset = result['nextOffset'] # v7
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section"&gt;必要なもの&lt;/h1&gt;
&lt;p&gt;本の4章の始めの方に必要な部品やハードウェアのリストがあるが、そこに載ってあるもの以外に下記が必要となる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Micro SD カード（これに Windows 10 IoT を書き込んで Raspberry Pi に挿す）&lt;/li&gt;
&lt;li&gt;Micro SD カードの Reader/Writer（書き込む用）&lt;/li&gt;
&lt;li&gt;A-B USB ケーブル（PC と Arduino 接続用）&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>ブログ移行しました</title>
			<link>http://ojikeii.net/posts/2018-01-08</link>
			<description>&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/hagej_60527/"&gt;以前のブログ&lt;/a&gt;はそのまま残してあります。&lt;/p&gt;</description>
			<guid>http://ojikeii.net/posts/2018-01-08</guid>
			<pubDate>Mon, 08 Jan 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/hagej_60527/"&gt;以前のブログ&lt;/a&gt;はそのまま残してあります。&lt;/p&gt;
</content:encoded>
		</item>
	</channel>
</rss>